
#import "Compiler"; // for version info

// TODO: probably create some table for preload structures?
// Or just do an array lookup

// [..] struct { version: Version_Info; ...not sure what to put here tbh };

// NOTE: we should really only create versioned structs for the type info structures that actually change.
//       so, for example, here we should only have a struct for Type_Info_Struct, since that's all that changed form 012 to 014
//       but then we have a problem about making sure the pointers to other type info types point to the proper versions..
//       for unpack_data, we will probably just have to make sure the preload version is passed as some context variable, so that we can respect it in recast_type_info
//       for now though, I've just duplicated all of the preload type info structures and namespaced them so that they're internally consistent.

Preload_0_2_012 :: struct {
    Type_Info_Tag :: enum u32 {
        INTEGER              :: 0;
        FLOAT                :: 1;
        BOOL                 :: 2;
        STRING               :: 3;
        POINTER              :: 4;
        PROCEDURE            :: 5;
        VOID                 :: 6;
        STRUCT               :: 7;
        ARRAY                :: 8;
        OVERLOAD_SET         :: 9;
        ANY                  :: 10;
        ENUM                 :: 11;
        POLYMORPHIC_VARIABLE :: 12;
        TYPE                 :: 13;
        CODE                 :: 14;
        UNTYPED_LITERAL      :: 15;
        UNTYPED_ENUM         :: 16;
    
        VARIANT              :: 18;
    }
    
    
    // The Type_Infos all need to be here because when you say
    // type_info(x), we downcast to the most specific Type_Info.
    // This is useful. But requires more in the preload. Sigh!
    
    Type_Info :: struct {
        type: Type_Info_Tag;
        runtime_size:    s64;  // WARNING: runtime_size may be unset for structs at compile-time if compilation is not finished. (It will be -1 in this case.) It can also be -1 if the type is polymorphic.
    }
    
    Type_Info_Integer :: struct {
        using #as info: Type_Info;
        signed: bool;
    }
    
    Type_Info_Float :: struct {
        using #as info: Type_Info;
    }
    
    // There is no Type_Info_Bool.
    
    // Type_Info_String is currently useless; we may get rid of it eventually.
    Type_Info_String :: struct {
        using #as info: Type_Info;
    }
    
    Type_Info_Pointer :: struct {
        using #as info: Type_Info;
    
        pointer_to: *Type_Info;
    }
    
    Type_Info_Procedure :: struct {
        using #as info: Type_Info;
    
        argument_types: [] *Type_Info;
        return_types:   [] *Type_Info;
    
        procedure_flags: Flags;
    
        Flags :: enum_flags u32 {
            IS_ELSEWHERE    :: 0x1;
            IS_COMPILE_TIME_ONLY :: 0x2;
            IS_POLYMORPHIC  :: 0x4;
            HAS_NO_CONTEXT  :: 0x8;
            IS_C_CALL       :: 0x20;
            IS_INTRINSIC    :: 0x80;
            IS_SYMMETRIC    :: 0x100;
    
            IS_CPP_METHOD   :: 0x1000_0000;
            HAS_CPP_NON_POD_RETURN_TYPE :: 0x2000_0000;
        }
    }
    
    // There is no Type_Info_Void.
    
    Struct_Nontextual_Flags :: enum_flags u32 { // These are things not written by the user, but that get generated by the compiler.
        NOT_INSTANTIABLE          :: 0x4;
        ALL_MEMBERS_UNINITIALIZED :: 0x40;
        POLYMORPHIC               :: 0x100;
    }
    
    Struct_Textual_Flags :: enum u32 {
        FOREIGN                                :: 0x1;
        UNION                                  :: 0x2;
        NO_PADDING                             :: 0x4;
        TYPE_INFO_NONE                         :: 0x8;
        TYPE_INFO_NO_SIZE_COMPLAINT            :: 0x10;
        TYPE_INFO_PROCEDURES_ARE_VOID_POINTERS :: 0x20;
    }
    
    Struct_Status_Flags :: enum_flags u32 {
        INCOMPLETE :: 0x1;
        LOCAL      :: 0x4;
    }
        
    Type_Info_Struct :: struct {
        using #as info: Type_Info;
    
        name: string;
    
        // parameters:           [] Type_Info_Struct_Member; // These are unspecified parameters. Concrete, usable-at-runtime structs will not have these, but if you look at the polymorph_source_struct, it will have parameters.
        
        specified_parameters: [] Type_Info_Struct_Member; // These are parameters of the polymorph_source_struct that have been specified here.
        members:              [] Type_Info_Struct_Member;
    
        status_flags:     Struct_Status_Flags;
        nontextual_flags: Struct_Nontextual_Flags;
        textual_flags:    Struct_Textual_Flags;
    
        polymorph_source_struct: *Type_Info_Struct;
    
        initializer: (*void) #no_context;
    
        constant_storage: [] u8;
        notes: [] string;
    }
        
    Type_Info_Struct_Member :: struct {
        name: string;
        type: *Type_Info;
        offset_in_bytes: s64;
    
        flags: Flags;
    
        notes: [] string;
    
        offset_into_constant_storage: s64 = -1;  // -1 if this is not in constant storage; >=0 otherwise.
    
        Flags :: enum_flags u32 {
            CONSTANT                              :: 0x1;
            IMPORTED                              :: 0x2;
            USING                                 :: 0x4;
            PROCEDURE_WITH_VOID_POINTER_TYPE_INFO :: 0x8;
            AS                                    :: 0x10;
        }
    }
    
    Type_Info_Array :: struct {
        using #as info: Type_Info;
    
        element_type: *Type_Info;
    
        array_type:            Array_Type;
        // (hole)
    
        array_count:           s64;        // -1 unless this array is is of a known compile-time size, i.e. array_type is FIXED.
    
        Array_Type :: enum u16 {
            FIXED     :: 0;
            VIEW      :: 1;
            RESIZABLE :: 2;
        }
    }
    
    // There is no Type_Info_Any.
    
    Enum_Status_Flags :: enum_flags u16 {
        INCOMPLETE :: 0x1;
    }
    
    Enum_Type_Flags :: enum_flags u16 {
        FLAGS     :: 0x1;  // This means it's declared as an enum_flags, not an enum. Confusing because we are in an enum that itself is called Flags, that has nothing to do with this.
        COMPLETE  :: 0x2;  // Enum is marked as #complete.
        SPECIFIED :: 0x4;  // Enum is marked as #specified.
    }
    
    Type_Info_Enum :: struct {
        using #as info: Type_Info;
    
        name: string;
        internal_type: *Type_Info_Integer;
    
        names:         [] string;
        values:        [] s64;
    
        status_flags:    Enum_Status_Flags;
        enum_type_flags: Enum_Type_Flags;
    }
    
    Type_Info_Variant_Flags :: enum_flags u32 {
        DISTINCT :: 0x1;
        ISA      :: 0x2;
    }
    
    Type_Info_Variant :: struct {
        using #as info: Type_Info;
    
        name:          string;
        variant_of:    *Type_Info;
        variant_flags: Type_Info_Variant_Flags;
    }
    
    // There is no Type_Info_Polymorphic_Variable.
    // There is no Type_Info_Type.
}